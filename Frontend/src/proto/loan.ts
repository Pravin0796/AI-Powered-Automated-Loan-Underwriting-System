// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.14.0
// source: loan.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";

export const protobufPackage = "loan";

export interface LoanRequest {
  userId: number;
  ssn: string;
  /** "urban" or "rural" */
  addressArea: string;
  loanAmount: number;
  loanPurpose: string;
  employmentStatus: string;
  grossMonthlyIncome: number;
  totalMonthlyDebtPayment: number;
}

export interface LoanResponse {
  /** Unique loan ID */
  loanId: number;
  /** Loan status (e.g., "Pending", "Approved", "Rejected") */
  status: string;
}

export interface LoanStatusRequest {
  /** Loan ID to get status of */
  loanId: number;
}

export interface LoanStatusResponse {
  /** Loan ID */
  loanId: number;
  /** Loan application status */
  status: string;
}

export interface LoanApplicationRequest {
  /** Request details of a specific loan application */
  loanId: number;
}

export interface LoanApplicationResponse {
  loanId: number;
  userName: string;
  ssn: string;
  addressArea: string;
  loanAmount: number;
  loanPurpose: string;
  employmentStatus: string;
  grossMonthlyIncome: number;
  totalMonthlyDebtPayment: number;
  dtiRatio: number;
  applicationStatus: string;
  creditReportFetched: boolean;
  experianRequestId: string;
  creditScore: number;
  reasoning: string;
  createdAt: string;
  updatedAt: string;
  deletedAt: string;
}

export interface Empty {
}

export interface LoanApplicationList {
  applications: LoanApplicationResponse[];
}

export interface UpdateApplicationStatusRequest {
  loanApplicationId: number;
  /** Approved, Rejected, etc. */
  newStatus: string;
  reasoning: string;
}

export interface UpdateApplicationStatusResponse {
  status: string;
}

export interface LoanStatsResponse {
  totalApplications: number;
  approved: number;
  rejected: number;
  pending: number;
}

function createBaseLoanRequest(): LoanRequest {
  return {
    userId: 0,
    ssn: "",
    addressArea: "",
    loanAmount: 0,
    loanPurpose: "",
    employmentStatus: "",
    grossMonthlyIncome: 0,
    totalMonthlyDebtPayment: 0,
  };
}

export const LoanRequest: MessageFns<LoanRequest> = {
  encode(message: LoanRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).uint64(message.userId);
    }
    if (message.ssn !== "") {
      writer.uint32(18).string(message.ssn);
    }
    if (message.addressArea !== "") {
      writer.uint32(26).string(message.addressArea);
    }
    if (message.loanAmount !== 0) {
      writer.uint32(33).double(message.loanAmount);
    }
    if (message.loanPurpose !== "") {
      writer.uint32(42).string(message.loanPurpose);
    }
    if (message.employmentStatus !== "") {
      writer.uint32(50).string(message.employmentStatus);
    }
    if (message.grossMonthlyIncome !== 0) {
      writer.uint32(57).double(message.grossMonthlyIncome);
    }
    if (message.totalMonthlyDebtPayment !== 0) {
      writer.uint32(65).double(message.totalMonthlyDebtPayment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoanRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoanRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ssn = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addressArea = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.loanAmount = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.loanPurpose = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.employmentStatus = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.grossMonthlyIncome = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.totalMonthlyDebtPayment = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoanRequest {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      ssn: isSet(object.ssn) ? globalThis.String(object.ssn) : "",
      addressArea: isSet(object.addressArea) ? globalThis.String(object.addressArea) : "",
      loanAmount: isSet(object.loanAmount) ? globalThis.Number(object.loanAmount) : 0,
      loanPurpose: isSet(object.loanPurpose) ? globalThis.String(object.loanPurpose) : "",
      employmentStatus: isSet(object.employmentStatus) ? globalThis.String(object.employmentStatus) : "",
      grossMonthlyIncome: isSet(object.grossMonthlyIncome) ? globalThis.Number(object.grossMonthlyIncome) : 0,
      totalMonthlyDebtPayment: isSet(object.totalMonthlyDebtPayment)
        ? globalThis.Number(object.totalMonthlyDebtPayment)
        : 0,
    };
  },

  toJSON(message: LoanRequest): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.ssn !== "") {
      obj.ssn = message.ssn;
    }
    if (message.addressArea !== "") {
      obj.addressArea = message.addressArea;
    }
    if (message.loanAmount !== 0) {
      obj.loanAmount = message.loanAmount;
    }
    if (message.loanPurpose !== "") {
      obj.loanPurpose = message.loanPurpose;
    }
    if (message.employmentStatus !== "") {
      obj.employmentStatus = message.employmentStatus;
    }
    if (message.grossMonthlyIncome !== 0) {
      obj.grossMonthlyIncome = message.grossMonthlyIncome;
    }
    if (message.totalMonthlyDebtPayment !== 0) {
      obj.totalMonthlyDebtPayment = message.totalMonthlyDebtPayment;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoanRequest>, I>>(base?: I): LoanRequest {
    return LoanRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoanRequest>, I>>(object: I): LoanRequest {
    const message = createBaseLoanRequest();
    message.userId = object.userId ?? 0;
    message.ssn = object.ssn ?? "";
    message.addressArea = object.addressArea ?? "";
    message.loanAmount = object.loanAmount ?? 0;
    message.loanPurpose = object.loanPurpose ?? "";
    message.employmentStatus = object.employmentStatus ?? "";
    message.grossMonthlyIncome = object.grossMonthlyIncome ?? 0;
    message.totalMonthlyDebtPayment = object.totalMonthlyDebtPayment ?? 0;
    return message;
  },
};

function createBaseLoanResponse(): LoanResponse {
  return { loanId: 0, status: "" };
}

export const LoanResponse: MessageFns<LoanResponse> = {
  encode(message: LoanResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.loanId !== 0) {
      writer.uint32(8).uint64(message.loanId);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoanResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoanResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.loanId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoanResponse {
    return {
      loanId: isSet(object.loanId) ? globalThis.Number(object.loanId) : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: LoanResponse): unknown {
    const obj: any = {};
    if (message.loanId !== 0) {
      obj.loanId = Math.round(message.loanId);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoanResponse>, I>>(base?: I): LoanResponse {
    return LoanResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoanResponse>, I>>(object: I): LoanResponse {
    const message = createBaseLoanResponse();
    message.loanId = object.loanId ?? 0;
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseLoanStatusRequest(): LoanStatusRequest {
  return { loanId: 0 };
}

export const LoanStatusRequest: MessageFns<LoanStatusRequest> = {
  encode(message: LoanStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.loanId !== 0) {
      writer.uint32(8).uint64(message.loanId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoanStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoanStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.loanId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoanStatusRequest {
    return { loanId: isSet(object.loanId) ? globalThis.Number(object.loanId) : 0 };
  },

  toJSON(message: LoanStatusRequest): unknown {
    const obj: any = {};
    if (message.loanId !== 0) {
      obj.loanId = Math.round(message.loanId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoanStatusRequest>, I>>(base?: I): LoanStatusRequest {
    return LoanStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoanStatusRequest>, I>>(object: I): LoanStatusRequest {
    const message = createBaseLoanStatusRequest();
    message.loanId = object.loanId ?? 0;
    return message;
  },
};

function createBaseLoanStatusResponse(): LoanStatusResponse {
  return { loanId: 0, status: "" };
}

export const LoanStatusResponse: MessageFns<LoanStatusResponse> = {
  encode(message: LoanStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.loanId !== 0) {
      writer.uint32(8).uint64(message.loanId);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoanStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoanStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.loanId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoanStatusResponse {
    return {
      loanId: isSet(object.loanId) ? globalThis.Number(object.loanId) : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: LoanStatusResponse): unknown {
    const obj: any = {};
    if (message.loanId !== 0) {
      obj.loanId = Math.round(message.loanId);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoanStatusResponse>, I>>(base?: I): LoanStatusResponse {
    return LoanStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoanStatusResponse>, I>>(object: I): LoanStatusResponse {
    const message = createBaseLoanStatusResponse();
    message.loanId = object.loanId ?? 0;
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseLoanApplicationRequest(): LoanApplicationRequest {
  return { loanId: 0 };
}

export const LoanApplicationRequest: MessageFns<LoanApplicationRequest> = {
  encode(message: LoanApplicationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.loanId !== 0) {
      writer.uint32(8).uint64(message.loanId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoanApplicationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoanApplicationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.loanId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoanApplicationRequest {
    return { loanId: isSet(object.loanId) ? globalThis.Number(object.loanId) : 0 };
  },

  toJSON(message: LoanApplicationRequest): unknown {
    const obj: any = {};
    if (message.loanId !== 0) {
      obj.loanId = Math.round(message.loanId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoanApplicationRequest>, I>>(base?: I): LoanApplicationRequest {
    return LoanApplicationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoanApplicationRequest>, I>>(object: I): LoanApplicationRequest {
    const message = createBaseLoanApplicationRequest();
    message.loanId = object.loanId ?? 0;
    return message;
  },
};

function createBaseLoanApplicationResponse(): LoanApplicationResponse {
  return {
    loanId: 0,
    userName: "",
    ssn: "",
    addressArea: "",
    loanAmount: 0,
    loanPurpose: "",
    employmentStatus: "",
    grossMonthlyIncome: 0,
    totalMonthlyDebtPayment: 0,
    dtiRatio: 0,
    applicationStatus: "",
    creditReportFetched: false,
    experianRequestId: "",
    creditScore: 0,
    reasoning: "",
    createdAt: "",
    updatedAt: "",
    deletedAt: "",
  };
}

export const LoanApplicationResponse: MessageFns<LoanApplicationResponse> = {
  encode(message: LoanApplicationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.loanId !== 0) {
      writer.uint32(8).uint64(message.loanId);
    }
    if (message.userName !== "") {
      writer.uint32(18).string(message.userName);
    }
    if (message.ssn !== "") {
      writer.uint32(26).string(message.ssn);
    }
    if (message.addressArea !== "") {
      writer.uint32(34).string(message.addressArea);
    }
    if (message.loanAmount !== 0) {
      writer.uint32(41).double(message.loanAmount);
    }
    if (message.loanPurpose !== "") {
      writer.uint32(50).string(message.loanPurpose);
    }
    if (message.employmentStatus !== "") {
      writer.uint32(58).string(message.employmentStatus);
    }
    if (message.grossMonthlyIncome !== 0) {
      writer.uint32(65).double(message.grossMonthlyIncome);
    }
    if (message.totalMonthlyDebtPayment !== 0) {
      writer.uint32(73).double(message.totalMonthlyDebtPayment);
    }
    if (message.dtiRatio !== 0) {
      writer.uint32(81).double(message.dtiRatio);
    }
    if (message.applicationStatus !== "") {
      writer.uint32(90).string(message.applicationStatus);
    }
    if (message.creditReportFetched !== false) {
      writer.uint32(96).bool(message.creditReportFetched);
    }
    if (message.experianRequestId !== "") {
      writer.uint32(106).string(message.experianRequestId);
    }
    if (message.creditScore !== 0) {
      writer.uint32(112).int32(message.creditScore);
    }
    if (message.reasoning !== "") {
      writer.uint32(122).string(message.reasoning);
    }
    if (message.createdAt !== "") {
      writer.uint32(130).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(138).string(message.updatedAt);
    }
    if (message.deletedAt !== "") {
      writer.uint32(146).string(message.deletedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoanApplicationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoanApplicationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.loanId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ssn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.addressArea = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.loanAmount = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.loanPurpose = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.employmentStatus = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.grossMonthlyIncome = reader.double();
          continue;
        }
        case 9: {
          if (tag !== 73) {
            break;
          }

          message.totalMonthlyDebtPayment = reader.double();
          continue;
        }
        case 10: {
          if (tag !== 81) {
            break;
          }

          message.dtiRatio = reader.double();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.applicationStatus = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.creditReportFetched = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.experianRequestId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.creditScore = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.reasoning = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.deletedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoanApplicationResponse {
    return {
      loanId: isSet(object.loanId) ? globalThis.Number(object.loanId) : 0,
      userName: isSet(object.userName) ? globalThis.String(object.userName) : "",
      ssn: isSet(object.ssn) ? globalThis.String(object.ssn) : "",
      addressArea: isSet(object.addressArea) ? globalThis.String(object.addressArea) : "",
      loanAmount: isSet(object.loanAmount) ? globalThis.Number(object.loanAmount) : 0,
      loanPurpose: isSet(object.loanPurpose) ? globalThis.String(object.loanPurpose) : "",
      employmentStatus: isSet(object.employmentStatus) ? globalThis.String(object.employmentStatus) : "",
      grossMonthlyIncome: isSet(object.grossMonthlyIncome) ? globalThis.Number(object.grossMonthlyIncome) : 0,
      totalMonthlyDebtPayment: isSet(object.totalMonthlyDebtPayment)
        ? globalThis.Number(object.totalMonthlyDebtPayment)
        : 0,
      dtiRatio: isSet(object.dtiRatio) ? globalThis.Number(object.dtiRatio) : 0,
      applicationStatus: isSet(object.applicationStatus) ? globalThis.String(object.applicationStatus) : "",
      creditReportFetched: isSet(object.creditReportFetched) ? globalThis.Boolean(object.creditReportFetched) : false,
      experianRequestId: isSet(object.experianRequestId) ? globalThis.String(object.experianRequestId) : "",
      creditScore: isSet(object.creditScore) ? globalThis.Number(object.creditScore) : 0,
      reasoning: isSet(object.reasoning) ? globalThis.String(object.reasoning) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "",
      deletedAt: isSet(object.deletedAt) ? globalThis.String(object.deletedAt) : "",
    };
  },

  toJSON(message: LoanApplicationResponse): unknown {
    const obj: any = {};
    if (message.loanId !== 0) {
      obj.loanId = Math.round(message.loanId);
    }
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    if (message.ssn !== "") {
      obj.ssn = message.ssn;
    }
    if (message.addressArea !== "") {
      obj.addressArea = message.addressArea;
    }
    if (message.loanAmount !== 0) {
      obj.loanAmount = message.loanAmount;
    }
    if (message.loanPurpose !== "") {
      obj.loanPurpose = message.loanPurpose;
    }
    if (message.employmentStatus !== "") {
      obj.employmentStatus = message.employmentStatus;
    }
    if (message.grossMonthlyIncome !== 0) {
      obj.grossMonthlyIncome = message.grossMonthlyIncome;
    }
    if (message.totalMonthlyDebtPayment !== 0) {
      obj.totalMonthlyDebtPayment = message.totalMonthlyDebtPayment;
    }
    if (message.dtiRatio !== 0) {
      obj.dtiRatio = message.dtiRatio;
    }
    if (message.applicationStatus !== "") {
      obj.applicationStatus = message.applicationStatus;
    }
    if (message.creditReportFetched !== false) {
      obj.creditReportFetched = message.creditReportFetched;
    }
    if (message.experianRequestId !== "") {
      obj.experianRequestId = message.experianRequestId;
    }
    if (message.creditScore !== 0) {
      obj.creditScore = Math.round(message.creditScore);
    }
    if (message.reasoning !== "") {
      obj.reasoning = message.reasoning;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.deletedAt !== "") {
      obj.deletedAt = message.deletedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoanApplicationResponse>, I>>(base?: I): LoanApplicationResponse {
    return LoanApplicationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoanApplicationResponse>, I>>(object: I): LoanApplicationResponse {
    const message = createBaseLoanApplicationResponse();
    message.loanId = object.loanId ?? 0;
    message.userName = object.userName ?? "";
    message.ssn = object.ssn ?? "";
    message.addressArea = object.addressArea ?? "";
    message.loanAmount = object.loanAmount ?? 0;
    message.loanPurpose = object.loanPurpose ?? "";
    message.employmentStatus = object.employmentStatus ?? "";
    message.grossMonthlyIncome = object.grossMonthlyIncome ?? 0;
    message.totalMonthlyDebtPayment = object.totalMonthlyDebtPayment ?? 0;
    message.dtiRatio = object.dtiRatio ?? 0;
    message.applicationStatus = object.applicationStatus ?? "";
    message.creditReportFetched = object.creditReportFetched ?? false;
    message.experianRequestId = object.experianRequestId ?? "";
    message.creditScore = object.creditScore ?? 0;
    message.reasoning = object.reasoning ?? "";
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.deletedAt = object.deletedAt ?? "";
    return message;
  },
};

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseLoanApplicationList(): LoanApplicationList {
  return { applications: [] };
}

export const LoanApplicationList: MessageFns<LoanApplicationList> = {
  encode(message: LoanApplicationList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.applications) {
      LoanApplicationResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoanApplicationList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoanApplicationList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.applications.push(LoanApplicationResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoanApplicationList {
    return {
      applications: globalThis.Array.isArray(object?.applications)
        ? object.applications.map((e: any) => LoanApplicationResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LoanApplicationList): unknown {
    const obj: any = {};
    if (message.applications?.length) {
      obj.applications = message.applications.map((e) => LoanApplicationResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoanApplicationList>, I>>(base?: I): LoanApplicationList {
    return LoanApplicationList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoanApplicationList>, I>>(object: I): LoanApplicationList {
    const message = createBaseLoanApplicationList();
    message.applications = object.applications?.map((e) => LoanApplicationResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateApplicationStatusRequest(): UpdateApplicationStatusRequest {
  return { loanApplicationId: 0, newStatus: "", reasoning: "" };
}

export const UpdateApplicationStatusRequest: MessageFns<UpdateApplicationStatusRequest> = {
  encode(message: UpdateApplicationStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.loanApplicationId !== 0) {
      writer.uint32(8).uint64(message.loanApplicationId);
    }
    if (message.newStatus !== "") {
      writer.uint32(18).string(message.newStatus);
    }
    if (message.reasoning !== "") {
      writer.uint32(26).string(message.reasoning);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateApplicationStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateApplicationStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.loanApplicationId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newStatus = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reasoning = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateApplicationStatusRequest {
    return {
      loanApplicationId: isSet(object.loanApplicationId) ? globalThis.Number(object.loanApplicationId) : 0,
      newStatus: isSet(object.newStatus) ? globalThis.String(object.newStatus) : "",
      reasoning: isSet(object.reasoning) ? globalThis.String(object.reasoning) : "",
    };
  },

  toJSON(message: UpdateApplicationStatusRequest): unknown {
    const obj: any = {};
    if (message.loanApplicationId !== 0) {
      obj.loanApplicationId = Math.round(message.loanApplicationId);
    }
    if (message.newStatus !== "") {
      obj.newStatus = message.newStatus;
    }
    if (message.reasoning !== "") {
      obj.reasoning = message.reasoning;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateApplicationStatusRequest>, I>>(base?: I): UpdateApplicationStatusRequest {
    return UpdateApplicationStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateApplicationStatusRequest>, I>>(
    object: I,
  ): UpdateApplicationStatusRequest {
    const message = createBaseUpdateApplicationStatusRequest();
    message.loanApplicationId = object.loanApplicationId ?? 0;
    message.newStatus = object.newStatus ?? "";
    message.reasoning = object.reasoning ?? "";
    return message;
  },
};

function createBaseUpdateApplicationStatusResponse(): UpdateApplicationStatusResponse {
  return { status: "" };
}

export const UpdateApplicationStatusResponse: MessageFns<UpdateApplicationStatusResponse> = {
  encode(message: UpdateApplicationStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateApplicationStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateApplicationStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateApplicationStatusResponse {
    return { status: isSet(object.status) ? globalThis.String(object.status) : "" };
  },

  toJSON(message: UpdateApplicationStatusResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateApplicationStatusResponse>, I>>(base?: I): UpdateApplicationStatusResponse {
    return UpdateApplicationStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateApplicationStatusResponse>, I>>(
    object: I,
  ): UpdateApplicationStatusResponse {
    const message = createBaseUpdateApplicationStatusResponse();
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseLoanStatsResponse(): LoanStatsResponse {
  return { totalApplications: 0, approved: 0, rejected: 0, pending: 0 };
}

export const LoanStatsResponse: MessageFns<LoanStatsResponse> = {
  encode(message: LoanStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalApplications !== 0) {
      writer.uint32(8).uint32(message.totalApplications);
    }
    if (message.approved !== 0) {
      writer.uint32(16).uint32(message.approved);
    }
    if (message.rejected !== 0) {
      writer.uint32(24).uint32(message.rejected);
    }
    if (message.pending !== 0) {
      writer.uint32(32).uint32(message.pending);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoanStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoanStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalApplications = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.approved = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rejected = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pending = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoanStatsResponse {
    return {
      totalApplications: isSet(object.totalApplications) ? globalThis.Number(object.totalApplications) : 0,
      approved: isSet(object.approved) ? globalThis.Number(object.approved) : 0,
      rejected: isSet(object.rejected) ? globalThis.Number(object.rejected) : 0,
      pending: isSet(object.pending) ? globalThis.Number(object.pending) : 0,
    };
  },

  toJSON(message: LoanStatsResponse): unknown {
    const obj: any = {};
    if (message.totalApplications !== 0) {
      obj.totalApplications = Math.round(message.totalApplications);
    }
    if (message.approved !== 0) {
      obj.approved = Math.round(message.approved);
    }
    if (message.rejected !== 0) {
      obj.rejected = Math.round(message.rejected);
    }
    if (message.pending !== 0) {
      obj.pending = Math.round(message.pending);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoanStatsResponse>, I>>(base?: I): LoanStatsResponse {
    return LoanStatsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoanStatsResponse>, I>>(object: I): LoanStatsResponse {
    const message = createBaseLoanStatsResponse();
    message.totalApplications = object.totalApplications ?? 0;
    message.approved = object.approved ?? 0;
    message.rejected = object.rejected ?? 0;
    message.pending = object.pending ?? 0;
    return message;
  },
};

export interface LoanService {
  ApplyForLoan(request: DeepPartial<LoanRequest>, metadata?: grpc.Metadata): Promise<LoanResponse>;
  GetLoanStatus(request: DeepPartial<LoanStatusRequest>, metadata?: grpc.Metadata): Promise<LoanStatusResponse>;
  GetLoanApplicationDetails(
    request: DeepPartial<LoanApplicationRequest>,
    metadata?: grpc.Metadata,
  ): Promise<LoanApplicationResponse>;
  GetAllLoanApplications(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<LoanApplicationList>;
  UpdateApplicationStatus(
    request: DeepPartial<UpdateApplicationStatusRequest>,
    metadata?: grpc.Metadata,
  ): Promise<UpdateApplicationStatusResponse>;
  GetLoanStatusCount(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<LoanStatsResponse>;
}

export class LoanServiceClientImpl implements LoanService {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.ApplyForLoan = this.ApplyForLoan.bind(this);
    this.GetLoanStatus = this.GetLoanStatus.bind(this);
    this.GetLoanApplicationDetails = this.GetLoanApplicationDetails.bind(this);
    this.GetAllLoanApplications = this.GetAllLoanApplications.bind(this);
    this.UpdateApplicationStatus = this.UpdateApplicationStatus.bind(this);
    this.GetLoanStatusCount = this.GetLoanStatusCount.bind(this);
  }

  ApplyForLoan(request: DeepPartial<LoanRequest>, metadata?: grpc.Metadata): Promise<LoanResponse> {
    return this.rpc.unary(LoanServiceApplyForLoanDesc, LoanRequest.fromPartial(request), metadata);
  }

  GetLoanStatus(request: DeepPartial<LoanStatusRequest>, metadata?: grpc.Metadata): Promise<LoanStatusResponse> {
    return this.rpc.unary(LoanServiceGetLoanStatusDesc, LoanStatusRequest.fromPartial(request), metadata);
  }

  GetLoanApplicationDetails(
    request: DeepPartial<LoanApplicationRequest>,
    metadata?: grpc.Metadata,
  ): Promise<LoanApplicationResponse> {
    return this.rpc.unary(
      LoanServiceGetLoanApplicationDetailsDesc,
      LoanApplicationRequest.fromPartial(request),
      metadata,
    );
  }

  GetAllLoanApplications(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<LoanApplicationList> {
    return this.rpc.unary(LoanServiceGetAllLoanApplicationsDesc, Empty.fromPartial(request), metadata);
  }

  UpdateApplicationStatus(
    request: DeepPartial<UpdateApplicationStatusRequest>,
    metadata?: grpc.Metadata,
  ): Promise<UpdateApplicationStatusResponse> {
    return this.rpc.unary(
      LoanServiceUpdateApplicationStatusDesc,
      UpdateApplicationStatusRequest.fromPartial(request),
      metadata,
    );
  }

  GetLoanStatusCount(request: DeepPartial<Empty>, metadata?: grpc.Metadata): Promise<LoanStatsResponse> {
    return this.rpc.unary(LoanServiceGetLoanStatusCountDesc, Empty.fromPartial(request), metadata);
  }
}

export const LoanServiceDesc = { serviceName: "loan.LoanService" };

export const LoanServiceApplyForLoanDesc: UnaryMethodDefinitionish = {
  methodName: "ApplyForLoan",
  service: LoanServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return LoanRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = LoanResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const LoanServiceGetLoanStatusDesc: UnaryMethodDefinitionish = {
  methodName: "GetLoanStatus",
  service: LoanServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return LoanStatusRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = LoanStatusResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const LoanServiceGetLoanApplicationDetailsDesc: UnaryMethodDefinitionish = {
  methodName: "GetLoanApplicationDetails",
  service: LoanServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return LoanApplicationRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = LoanApplicationResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const LoanServiceGetAllLoanApplicationsDesc: UnaryMethodDefinitionish = {
  methodName: "GetAllLoanApplications",
  service: LoanServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return Empty.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = LoanApplicationList.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const LoanServiceUpdateApplicationStatusDesc: UnaryMethodDefinitionish = {
  methodName: "UpdateApplicationStatus",
  service: LoanServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpdateApplicationStatusRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = UpdateApplicationStatusResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const LoanServiceGetLoanStatusCountDesc: UnaryMethodDefinitionish = {
  methodName: "GetLoanStatusCount",
  service: LoanServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return Empty.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = LoanStatsResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata ?? {},
        ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
        debug: this.options.debug ?? false,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
